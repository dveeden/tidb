// Copyright 2023 PingCAP, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
	"fmt"
	"log"
	"os"
	"regexp"
	"strings"
)

const (
	ReservedKeywordStart   = "The following tokens belong to ReservedKeyword"
	UnreservedkeywordStart = "The following tokens belong to UnReservedKeyword"
	NotKeywordStart        = "The following tokens belong to NotKeywordToken"
	TiDBKeywordStart       = "The following tokens belong to TiDBKeyword"
)

const (
	SectionNone = iota
	SectionReservedKeyword
	SectionUnreservedKeyword
	SectionTiDBKeyword
)

const (
	fileStart = `// Copyright 2023 PingCAP, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// See the License for the specific language governing permissions and
// limitations under the License.

package parser

// WARNING: This file is generated by 'genkeyword'

type KeywordsType struct {
	Word     string
	Reserved bool
}

var Keywords = []KeywordsType{
`
	fileEnd = `}
`
)

var keywordRe *regexp.Regexp

// parseLine extracts a keyword from a line of parser.y
// returns an empty string if there is no match.
//
// example data:
//
//	add               "ADD"
//
// Note that all keywords except `TiDB_CURRENT_TSO` are fully uppercase.
func parseLine(line string) string {
	if keywordRe == nil {
		keywordRe = regexp.MustCompile(`^\s+\w+\s+"(\w+)"$`)
	}
	m := keywordRe.FindStringSubmatch(line)
	if len(m) != 2 {
		return ""
	}
	return m[1]
}

func main() {
	parserData, err := os.ReadFile("parser.y")
	if err != nil {
		log.Fatalf("Failed to open parser.y: %s", err)
	}
	keywordsFile, err := os.OpenFile("keywords.go", os.O_CREATE|os.O_WRONLY, 0600)
	if err != nil {
		log.Fatalf("Failed to create keywords.go: %s", err)
	}
	_, err = keywordsFile.WriteString(fileStart)
	if err != nil {
		log.Fatalf("Failed to write fileStart to keywords.go: %s", err)
	}

	section := SectionNone
	for _, line := range strings.Split(string(parserData), "\n") {
		if line == "" { // Empty line indicates section end
			section = SectionNone
		} else if strings.Contains(line, ReservedKeywordStart) {
			section = SectionReservedKeyword
		} else if strings.Contains(line, UnreservedkeywordStart) {
			section = SectionUnreservedKeyword
		} else if strings.Contains(line, TiDBKeywordStart) {
			section = SectionTiDBKeyword
		} else if strings.Contains(line, NotKeywordStart) {
			section = SectionNone
		}

		switch section {
		case SectionReservedKeyword:
			word := parseLine(line)
			if len(word) > 0 {
				fmt.Fprintf(keywordsFile, "\t{\"%s\", true},\n", word)
			}
		case SectionTiDBKeyword:
			word := parseLine(line)
			if len(word) > 0 {
				fmt.Fprintf(keywordsFile, "\t{\"%s\", true},\n", word)
			}
		case SectionUnreservedKeyword:
			word := parseLine(line)
			if len(word) > 0 {
				fmt.Fprintf(keywordsFile, "\t{\"%s\", false},\n", word)
			}
		}
	}

	_, err = keywordsFile.WriteString(fileEnd)
	if err != nil {
		log.Fatalf("Failed to write fileEnd to keywords.go: %s", err)
	}
}
